#!/bin/bash
# Copyright © 2007       Kees Cook <kees@outflux.net>
# Copyright © 2007-2013  Roger Leigh <rleigh@codelibre.net>
#
# schroot is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# schroot is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
#
#####################################################################

set -e

. "$SETUP_DATA_DIR/common-data"
. "$SETUP_DATA_DIR/common-functions"
. "$SETUP_DATA_DIR/common-config"

# Wrapper around kill command. Turns errors into
# warnings when running in verbose mode, otherwise
# it ignores them.
# args: parameters for kill
kill_proc()
{
    if ! kill "$@" 2>/dev/null; then
        info "kill $@ failed: process already terminated?"
    fi
}

# Kill all processes that were run from within the chroot environment
# $1: mount base location
do_kill_all()
{
    if [ -z "$1" ]; then
        fatal "No path for finding stray processes: not reaping processes in chroot"
    fi

    if [ -z "$SCHROOT_KILL_WAIT_COUNTER" ]; then
        SCHROOT_KILL_WAIT_COUNTER=5
    fi

    if [ -z "$SCHROOT_KILL_WAIT_DELAY" ]; then
        SCHROOT_KILL_WAIT_DELAY=0.5
    fi

    chrootpath=$1

    info "[$(date +"%T,%N")] Killing processes run inside $chrootpath"

    # running processes will be added to array (key: pid | value: path to executable)
    declare -a killproclist=()

    # first, send SIGTERM to all running processes
    for pid in $(ls /proc | egrep '^[[:digit:]]+$'); do
        # Check if process root are the same device/inode as chroot
        # root (for efficiency)
        if [ /proc/"$pid"/root -ef "$chrootpath" ]; then
            # Check if process and chroot root are the same (may be
            # different even if device/inode match).
            root=$(readlink /proc/"$pid"/root || true)

            if [ "$root" = "$chrootpath" ]; then
                exe=$(readlink /proc/"$pid"/exe || true)

                # appending those processes to array
                killproclist[$pid]="${exe##$chrootpath}"

                info  "Killing left-over pid $pid (${killproclist[$pid]})"
                info  "  Sending SIGTERM to pid $pid"

                kill_proc -TERM "$pid"
            fi
        fi
    done

    # check for process termination in a loop, send SIGKILL afterwards
    for pid in ${!killproclist[*]}; do
        count=0
        max=$SCHROOT_KILL_WAIT_COUNTER
        while [ -d /proc/"$pid" ]; do
            count=$(( $count + 1 ))
            info "  Waiting for pid $pid to shut down... ($count/$max)"
            sleep $SCHROOT_KILL_WAIT_DELAY
            # Wait for $max seconds for process to die before -9'ing it
            if [ "$count" -eq "$max" ]; then
                info "  Sending SIGKILL to pid $pid"
                kill_proc -KILL "$pid"
                sleep $SCHROOT_KILL_WAIT_DELAY
                break
            fi
        done

        if [ ! -d /proc/"$pid" ]; then
            info "Process '${killproclist[$pid]}' ($pid) terminated."
        else
            fatal "Process '${killproclist[$pid]}' ($pid) NOT terminated."
        fi
    done

    info "[$(date +"%T,%N")] Finished killing processes run inside $chrootpath"
}

if [ $STAGE = "setup-recover" ] || [ $STAGE = "setup-stop" ]; then
    do_kill_all "$CHROOT_PATH"
fi
